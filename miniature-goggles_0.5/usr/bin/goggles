#!/usr/bin/env bash

# TODO: Stdin pipes are piped into command.
# TODO: Getops with options to specify the command, the output, no output, output format, option for interval.

#The user pipes a command into the system. The system calls that command and monitors it's mem, time, cpu (similar to top). The system outputs the usage in a table of text.
#
#The system must call arbitrary linux commands.
#The system must be aware of the mem usage of the call.
#The system must be aware of the cpu usage of the call.
#The system must be aware of the runtime usage of the call.
#The system must log the above resources at regular intervals.
#
#Bash:
#Run the command and get the PID.
#Every interval, get the ps aux line for that PID
#COMMAND:
#top -p PID -n 1 -b | tail -fn 1 | awk '{printf "%s,%s,%s,%s,%s\n",$1,$12,$9,$10,$11}'
#OUTPUT:
#PID,CMD,CPU,MEM,TIME

# BEHAVIOR:
# 1) pipes:
# foo | CMD | bar
# foo | goggles -o output.txt CMD | bar
# 2) solo
# goggles CMD
#
# If there is OUTPUT and no VERBOSE flag, don't use stdout
# If there is no output, use stdout
# Output defaults to stdout but is overridden by -o.
#
# SILENT = no CMD output to stdout.
# VERBOSE = goggle output is sent to stdout.

HELP="WIP"

# Defaults
for lastArg; do true; done # Get last argument.
COMMAND=$lastArg
FORMAT='vsz,rss,etimes'
INTERVAL=1
VERBOSE=FALSE
SILENT=FALSE
OUTPUT=""

# Parse options
while getopts ":c:vso:f:i:h" opt; do
  case $opt in
    c)
      COMMAND=$OPTARG
      ;;
    v)
      VERBOSE=TRUE
      ;;
    s)
      SILENT=TRUE
      ;;
    o)
      OUTPUT="$OPTARG"
      ;;
    f)
      FORMAT=$OPTARG
      ;;
    i)
      INTERVAL=$OPTARG
      ;;
    h)
      echo $HELP
      exit 0
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
  esac
done

# Run the command and save the PID to a variable.
CMD_PID=''
if [ $SILENT == 'FALSE' ]; then
    eval "(${COMMAND}) < /dev/stdin &"
else
    eval "(${COMMAND}) > /dev/null &"
fi
CMD_PID=$!

trap "kill ${CMD_PID} 2> /dev/null" EXIT # If this script is killed, kill the command.
if [ -z "$OUTPUT" ]; then
    top -p ${CMD_PID} -n 1 -b | tail -fn 1 | awk '{printf "%s %s\n",$1,$12}'
else
    `top -p ${CMD_PID} -n 1 -b | tail -fn 1 | awk '{printf "%s %s\n",$1,$12}' > $OUTPUT`
fi

COUNT=0
while kill -0 ${CMD_PID} 2> /dev/null; do # Monitor loop while proc is running.
    if [[ $COUNT == 0 ]]; then
        if [ -z "$OUTPUT" ]; then
            eval "ps -o $FORMAT ${CMD_PID}"
        else
            eval "ps -o $FORMAT ${CMD_PID} >> $OUTPUT"
        fi
    else
        if [ -z "$OUTPUT" ]; then
            eval "ps -o $FORMAT --no-headers ${CMD_PID}"
        else
            eval "ps -o $FORMAT --no-headers ${CMD_PID} >> $OUTPUT"
        fi
    fi
    sleep $INTERVAL
    ((COUNT++))
done
