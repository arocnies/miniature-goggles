#!/usr/bin/env bash

# TODO: Stdin pipes are piped into command.
# TODO: Getops with options to specify the command, the output, no output, output format, option for interval.

#The user pipes a command into the system. The system calls that command and monitors it's mem, time, cpu (similar to top). The system outputs the usage in a table of text.
#
#The system must call arbitrary linux commands.
#The system must be aware of the mem usage of the call.
#The system must be aware of the cpu usage of the call.
#The system must be aware of the runtime usage of the call.
#The system must log the above resources at regular intervals.
#
#Bash:
#Run the command and get the PID.
#Every interval, get the ps aux line for that PID
#COMMAND:
#top -p PID -n 1 -b | tail -fn 1 | awk '{printf "%s,%s,%s,%s,%s\n",$1,$12,$9,$10,$11}'
#OUTPUT:
#PID,CMD,CPU,MEM,TIME

HELP="WIP"

# Defaults
COMMAND=$1
FORMAT='vsz,rss,etimes'
INTERVAL=1

# Parse options
while getopts ":c:s:o:f:i:h" opt; do
  case $opt in
    c)
      COMMAND=$OPTARG
      ;;
    s)
      SILENT=TRUE
      ;;
    o)
      OUTPUT=$OPTARG
      ;;
    f)
      FORMAT=$OPTARG
      ;;
    i)
      INTERVAL=$OPTARG
      ;;
    h)
      echo $HELP
      exit 0
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
  esac
done

# Run the command and save the PID to a variable.
CMD_PID=''
if [ -z "$VAR" ]; then
    eval "(${COMMAND}) &"
else
    eval "(${COMMAND}) & > /dev/null"
fi
CMD_PID=$!

trap "kill ${CMD_PID} 2> /dev/null" EXIT # If this script is killed, kill the command.
top -p ${CMD_PID} -n 1 -b | tail -fn 1 | awk '{printf "%s %s\n",$1,$12}' # Output PID and command

COUNT=0
while kill -0 ${CMD_PID} 2> /dev/null; do # Monitor loop while proc is running.
    if [[ $COUNT == 0 ]]; then
        ps -o $FORMAT ${CMD_PID}
    else
        ps -o $FORMAT --no-headers ${CMD_PID}
    fi
    sleep $INTERVAL
    ((COUNT++))
done
