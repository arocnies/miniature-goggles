#!/usr/bin/env bash

# TODO: Stdin pipes are piped into command.
# TODO: Getops with options to specify the command, the output, no output, output format.

#The user pipes a command into the system. The system calls that command and monitors it's mem, time, cpu (similar to top). The system outputs the usage in a table of text.
#
#The system must call arbitrary linux commands.
#The system must be aware of the mem usage of the call.
#The system must be aware of the cpu usage of the call.
#The system must be aware of the runtime usage of the call.
#The system must log the above resources at regular intervals.
#
#Bash:
#Run the command and get the PID.
#Every interval, get the ps aux line for that PID
#COMMAND:
#top -p PID -n 1 -b | tail -fn 1 | awk '{printf "%s,%s,%s,%s,%s\n",$1,$12,$9,$10,$11}'
#OUTPUT:
#PID,CMD,CPU,MEM,TIME

# Defaults
COMMAND=$1
FORMAT='vsz,rss,etimes'

# Parse options
while getopts ":c:s:o:f:h" opt; do
  case $opt in
    c)
      COMMAND=$opt
      ;;
    s)
      SILENT=TRUE
      ;;
    o)
      OUTPUT=$opt
      ;;
    f)
      FORMAT=$opt
      ;;
    h)
      echo $HELP
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      ;;
  esac
done

# Run the command and save the PID to a variable.
CMD_PID=''
eval "(${COMMAND}) &"
CMD_PID=$!

trap "kill ${CMD_PID} 2> /dev/null" EXIT # If this script is killed, kill the command.
top -p ${CMD_PID} -n 1 -b | tail -fn 1 | awk '{printf "%s %s\n",$1,$12}' # Output PID and command

COUNT=0
while kill -0 ${CMD_PID} 2> /dev/null; do # Monitor loop while proc is running.
    if [[ $COUNT == 0 ]]; then
        ps -o vsz,rss,etimes ${CMD_PID}
    else
        ps -o vsz=,rss=,etimes= ${CMD_PID}
    fi
    sleep 1
    ((COUNT++))
done
